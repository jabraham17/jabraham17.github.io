class Opcode {
  //opcode and prefix are the DECIMAL representations
  constructor(opcode, prefix = null) {
    this.opcode = opcode;

    if (prefix == null) this.prefix = 0;
    else this.prefix = prefix;
  }
  equals(other) {
    if (this.constructor === other.constructor) {
      return this.opcode === other.opcode && this.prefix === other.prefix;
    } else return false;
  }
  //given 'this' and 'other'
  //returns 1 if 'this' comes after 'other'
  //-1 if 'this' comes before 'other'
  //0 if equal
  compareTo(other) {
    if (this.constructor === other.constructor) {
      //check prefix first, then if equal check opcode
      if (this.prefix < other.prefix) return -1;
      else if (this.prefix > other.prefix) return 1;
      else {
        if (this.opcode < other.opcode) return -1;
        else if (this.opcode > other.opcode) return 1;
        else return 0;
      }
    }
  }

  //convert value to a hex
  _toHex(val, nDigits = 2) {
    let hex = val.toString(16);
    while (hex.length < nDigits) {
      hex = "0" + hex;
    }
    return hex;
  }

  get prefix_hex() {
    return this._toHex(this.prefix, 2);
  }
  get opcode_hex() {
    return this._toHex(this.opcode, 2);
  }

  toString() {
    let p = this.prefix != 0 ? this.prefix_hex : "";
    let o = this.opcode_hex;
    return "0x" + p + o;
  }
}

const TYPES = Object.freeze({
  i32: 1,
  i64: 2,
  f32: 3,
  f64: 4,
  label: 5,
  label_list: 6,
  blocktype: 7,
  index: 8,
  memarg: 9,
  statement: 10,
  statement_list: 11,
  lane_index: 12,
});

function arrayCompare(a, b) {
  if (a.length === b.length) {
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  } else return false;
}

class StackEffect {
  //pop and push both have elms of TYPES
  constructor(pop = [], push = []) {
    this.pop = pop;
    this.push = push;
  }
  equals(other) {
    if (this.constructor === other.constructor) {
      return (
        arrayCompare(this.pop, other.pop) && arrayCompare(this.push, other.push)
      );
    } else return false;
  }

  get pop_str() {
    return this.pop.join(" ");
  }
  get push_str() {
    return this.push.join(" ");
  }

  toString() {
    let po = "[" + this.pop_str + "]";
    let pu = "[" + this.push_str + "]";
    return po + " -> " + pu;
  }
}

class Instruction {
  //name is string, opcode is Opcode, immediate is Immediate stack_effect is StackEffect
  constructor(
    name = null,
    opcode = null,
    immediate = null,
    stack_effect = null
  ) {
    this.name = name;
    this.opcode = opcode;
    this.immediate = immediate;
    this.stack_effect = stack_effect;
  }
  equals(other) {
    if (this.constructor === other.constructor) {
      return (
        this.name === other.name &&
        this.opcode.equals(other.opcode) &&
        arrayCompare(this.immediate, other.immediate) &&
        this.stack_effect.equals(other.stack_effect)
      );
    } else return false;
  }
  //given 'this' and 'other'
  //returns 1 if 'this' comes after 'other'
  //-1 if 'this' comes before 'other'
  //0 if equal
  compareTo(other) {
    if (!this.equals(other)) {
      return this.opcode.compareTo(other.opcode);
    } else return 0;
  }
}

//parses an instruction-index and returns a list of instructions
class InstructionParser {
  //these are very regular files, generated by a script
  //because of this it is very easy to parse

  constructor(rst) {
    this.lines = rst.split("\n");
    this.firstLine = this._findFirst();
    this.numEntries = this.lines.length - this.firstLine - 2;
    this.fieldLengths = this._findFieldLength(this.lines[this.firstLine - 1]);
    this.headers = this._getLine(this.lines[this.firstLine - 2]);
  }
  //find the first line for parsing
  _findFirst() {
    //find the 'Index of Instructions' line
    let starting = this.lines.findIndex((e) => e === "Index of Instructions");
    if (!starting) throw "Could not find starting point";
    //first line to parse
    return starting + 6;
  }
  //given a line of '=', determine field length
  _findFieldLength(format) {
    let fields = [];
    let eq_count = 0;
    let sp_count = 0;
    for (let c of format) {
      //count spaces and equals
      if (c === "=") eq_count++;
      else if (c === " ") sp_count++;
      //if at a break, add new field
      if (sp_count === 2) {
        fields.push(eq_count);
        eq_count = 0;
        sp_count = 0;
      }
    }
    if (eq_count !== 0) {
      fields.push(eq_count);
    }
    return fields;
  }
  //split raw line according to the field lengths
  _getLine(raw) {
    let line = [];

    for (let f of this.fieldLengths) {
      //get the first part of the line
      let newpart = raw.substr(0, f);
      newpart = newpart.trim();
      line.push(newpart);
      //remove part that was read
      raw = raw.substring(f + 2);
    }
    return line;
  }

  //convert the parsed types to the actual type
  _convertTypes(x) {
    if (x === "x") return "idx";
    else if (x === "xbt") return "bt";
    else if (x === "l") return "lbl";
    else if (x === "l^ast") return "lbl*";
    else if (x === "t") return "t";
    else if (x.match(/t(?:_[0-9])?\^ast/i)) {
      let y = x.replaceAll("^ast", "*");
      y = y.replaceAll("_", "");
      return y;
    }
    else if (x == "laneidx") return "idx";
    else return x;
  }

  //parse a name, getting its textual name and whether there is a immediate
  _parseName(raw) {
    let name = null;
    let imm = [];
    let m = raw.match(/:math:`([\s\S]+)`/i);
    if (m) {
      let cleaned = m[1];
      //remove all \K
      cleaned = cleaned.replaceAll("\\K", "");
      //replace \_ with _
      cleaned = cleaned.replaceAll("\\_", "_");
      //remove remaining \
      cleaned = cleaned.replaceAll("\\", "");
      //remove { or }
      cleaned = cleaned.replaceAll(/\{|\}/gi, "");
      //to lowercase
      cleaned = cleaned.toLowerCase();

      let name_imm = cleaned.split("~");
      name = name_imm[0];
      imm = name_imm.slice(1);
      //transform immediates into proper names
      imm = imm.map(this._convertTypes);
    }
    return { name, imm };
  }

  //parse the opcode, getting prefix and opcode
  _parseOpcode(raw) {
    let prefix = null;
    let opcode = null;

    let m = raw.match(/:math:`([\s\S]+)`/i);
    if (m) {
      let cleaned = m[1];

      if (cleaned.includes("~")) {
        //we have a prefix
        m = raw.match(
          /\\hex\{([a-f0-9]+)\}~{1,2}(?:\\hex\{)?([a-f0-9]+)(?:\})?/i
        );
        prefix = parseInt(m[1], 16);
        opcode = parseInt(m[2]);
      } else {
        //no prefix
        m = raw.match(/\\hex\{([a-f0-9]+)\}/i);
        opcode = parseInt(m[1], 16);
      }
    }
    return { prefix, opcode };
  }

  //parse a stack effect, getting push and pop
  _parseStack(raw) {
    let pop = [];
    let push = [];

    let m = raw.match(/:math:`([\s\S]+)`/i);
    if (m) {
      let cleaned = m[1];
      //remove remaining \
      cleaned = cleaned.replaceAll("\\", "");
      //to lowercase
      cleaned = cleaned.toLowerCase();

      m = cleaned.match(/\[([\s\S]*?)\].*?\[([\s\S]*?)\]/i);
      if (m) {
        pop = m[1].split("~");
        pop = pop.map(this._convertTypes);
        push = m[2].split("~");
        push = push.map(this._convertTypes);
      }
    }
    return { pop, push };
  }

  //parse
  parse() {
    return new Promise((resolve, reject) => {
      let actualLines = this.lines.slice(
        this.firstLine,
        this.firstLine + this.numEntries
      );
      if (typeof this.instructions === "undefined") {
        this.instructions = [];
        for (let raw_line of actualLines) {
          let line = this._getLine(raw_line);

          let { name, imm } = this._parseName(line[0]);
          let { prefix, opcode } = this._parseOpcode(line[1]);
          let { pop, push } = this._parseStack(line[2]);
          if (name) {
            let inst = new Instruction(
              name,
              new Opcode(opcode, prefix),
              imm,
              new StackEffect(pop, push)
            );
            this.instructions.push(inst);
          }
        }
      }
      resolve();
    });
  }
}

//parses a spec doc and stores all the instructions it find
class SpecDoc {
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }

  getSource() {
    return new Promise((resolve, reject) => {
      fetch(this.url)
        .then((r) => {
          //only parse to text if valid response
          if (r.ok) {
            r.text().then((raw) => {
              let parser = new InstructionParser(raw);
              parser.parse().then(() => {
                resolve(parser.instructions);
              });
            });
          } else {
            reject("Bad URL: " + this.url);
          }
        })
        .catch(reject);
    });
  }
}

// 1 if 'a' comes after 'b'
//-1 if 'a' comes before 'b'
//default is low to high
//returns negative if not found
function binarySearch(
  list,
  elm,
  compare = (a, b) => {
    return a > b ? 1 : a < b ? -1 : 0;
  }
) {
  //upper is inclusive
  let search = (lower, upper) => {
    let idx = -1;
    if (upper >= lower) {
      let middle_idx = Math.floor((lower + upper) / 2);
      // 1 if 'middle' comes after 'elm'
      //-1 if 'middle' comes before 'elm'
      let comp = compare(list[middle_idx], elm);
      //console.log(lower, middle_idx, upper, list.slice(lower, upper + 1));

      //if we found it, done
      if (comp == 0) {
        idx = middle_idx;
      }
      //check for base case, lower == upper
      else {
        if (comp > 0) idx = search(lower, middle_idx - 1);
        else if (comp < 0) idx = search(middle_idx + 1, upper);
      }
    } else idx = -(lower + 1); //accounts for 0
    return idx;
  };

  return search(0, list.length - 1);
}

//handle all searching and sorting for list
class InstructionList {
  constructor() {
    this.list = [];
    this.update_section = (idx, ...items) => {};
    this.update_all = (data) => {};
  }
  get length() {
    return this.list.length;
  }
  get empty() {
    return this.list.length == 0;
  }
  sort() {
    this.list.sort((a, b) => a.compareTo(b));
    this.add.update_all(this.list);
  }
  search(elm) {
    return binarySearch(this.list, elm, (a, b) => a.compareTo(b));
  }
  insert(idx, ...items) {
    this.list.splice(idx, 0, ...items);
    this.update_section(idx, ...items);
  }
  add(...items) {
    items.forEach((e) => {
      let idx = this.search(e);
      if (idx < 0) this.insert(-idx - 1, e);
    });
  }
}

//handle all searching and sorting for list
class InstructionTable {
  constructor() {
    this.container = document.querySelector("#wasm-ref");
    this.table = document.createElement("table");
    this.container.appendChild(this.table);
    this._buildHeader();

    this.body = document.createElement("tbody");
    this.table.appendChild(this.body);
  }

  _createRow(items, head = false) {
    let row = document.createElement("tr");
    let type = head ? "th" : "td";
    items.forEach((e) => {
      let i = document.createElement(type);
      i.appendChild(e);
      row.appendChild(i);
    });
    return row;
  }

  _createHeaderElm(content) {
    let elm = document.createElement("h3");
    elm.innerHTML = content;
    return elm;
  }

  _buildInst(inst) {
    let e1 = document.createElement("p");
    e1.innerHTML = inst.name;

    let e2 = document.createElement("p");
    e2.innerHTML = inst.opcode.toString();

    let e3 = document.createElement("p");
    e3.innerHTML = inst.stack_effect.toString();

    let e4 = document.createElement("p");
    e4.innerHTML = inst.immediate.join(" ");

    return [e1, e2, e3, e4];
  }

  _buildHeader() {
    let widthElm = document.createElement("colgroup");
    let widths = [35, 10, 35, 20];
    widths.forEach((e) => {
      let col = document.createElement("col");
      col.style.width = `${e}%`;
      widthElm.appendChild(col);
    });
    this.table.appendChild(widthElm);

    let head = document.createElement("thead");
    this.table.appendChild(head);
    let headElms = ["Instruction", "Opcode", "Stack", "Immediate"].map(
      this._createHeaderElm
    );
    head.appendChild(this._createRow(headElms, true));
  }

  addInst(idx, ...elms) {
    elms.forEach((e) => {
      //get the nth element
      let currentAtIdx = this.body.querySelector(`:nth-child(${idx})`);
      //make the new row
      let newRow = this._createRow(this._buildInst(e));
      //insert it
      this.body.insertBefore(newRow, currentAtIdx);
    });
  }
}

let urls = {
  core:
    "https://raw.githubusercontent.com/WebAssembly/spec/master/document/core/appendix/index-instructions.rst",
  simd:
    "https://raw.githubusercontent.com/WebAssembly/simd/master/document/core/appendix/index-instructions.rst",
  atomic:
    "https://raw.githubusercontent.com/WebAssembly/threads/master/document/core/appendix/index-instructions.rst",
  numeric:
    "https://raw.githubusercontent.com/WebAssembly/reference-types/master/document/core/appendix/index-instructions.rst",
  gc:
    "https://raw.githubusercontent.com/WebAssembly/gc/master/document/core/appendix/index-instructions.rst",
};

let sites = [];
for (let u in urls) {
  sites.push(new SpecDoc(u, urls[u]));
}

let instruction_list = new InstructionList();

let instruction_table = new InstructionTable();

instruction_list.update_section = (idx, ...items) => {
  //console.log(`insert at ${idx}: ${items.forEach(toString)}`)
  instruction_table.addInst(idx, ...items);
};

sites.forEach((e) =>
  e
    .getSource()
    .then((r) => {
      instruction_list.add(...r);
    })
    .catch(console.warn)
);
